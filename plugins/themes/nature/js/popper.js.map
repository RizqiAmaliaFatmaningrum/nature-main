{
version: 3,
file: "popper.js",
sources: [
"../../src/utils/isBrowser.js",
"../../src/utils/debounce.js",
"../../src/utils/isFunction.js",
"../../src/utils/getStyleComputedProperty.js",
"../../src/utils/getParentNode.js",
"../../src/utils/getScrollParent.js",
"../../src/utils/getReferenceNode.js",
"../../src/utils/isIE.js",
"../../src/utils/getOffsetParent.js",
"../../src/utils/isOffsetContainer.js",
"../../src/utils/getRoot.js",
"../../src/utils/findCommonOffsetParent.js",
"../../src/utils/getScroll.js",
"../../src/utils/includeScroll.js",
"../../src/utils/getBordersSize.js",
"../../src/utils/getWindowSizes.js",
"../../src/utils/getClientRect.js",
"../../src/utils/getBoundingClientRect.js",
"../../src/utils/getOffsetRectRelativeToArbitraryNode.js",
"../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js",
"../../src/utils/isFixed.js",
"../../src/utils/getFixedPositionOffsetParent.js",
"../../src/utils/getBoundaries.js",
"../../src/utils/computeAutoPlacement.js",
"../../src/utils/getReferenceOffsets.js",
"../../src/utils/getOuterSizes.js",
"../../src/utils/getOppositePlacement.js",
"../../src/utils/getPopperOffsets.js",
"../../src/utils/find.js",
"../../src/utils/findIndex.js",
"../../src/utils/runModifiers.js",
"../../src/methods/update.js",
"../../src/utils/isModifierEnabled.js",
"../../src/utils/getSupportedPropertyName.js",
"../../src/methods/destroy.js",
"../../src/utils/getWindow.js",
"../../src/utils/setupEventListeners.js",
"../../src/methods/enableEventListeners.js",
"../../src/utils/removeEventListeners.js",
"../../src/methods/disableEventListeners.js",
"../../src/utils/isNumeric.js",
"../../src/utils/setStyles.js",
"../../src/utils/setAttributes.js",
"../../src/modifiers/applyStyle.js",
"../../src/utils/getRoundedOffsets.js",
"../../src/modifiers/computeStyle.js",
"../../src/utils/isModifierRequired.js",
"../../src/modifiers/arrow.js",
"../../src/utils/getOppositeVariation.js",
"../../src/methods/placements.js",
"../../src/utils/clockwise.js",
"../../src/modifiers/flip.js",
"../../src/modifiers/keepTogether.js",
"../../src/modifiers/offset.js",
"../../src/modifiers/preventOverflow.js",
"../../src/modifiers/shift.js",
"../../src/modifiers/hide.js",
"../../src/modifiers/inner.js",
"../../src/modifiers/index.js",
"../../src/methods/defaults.js",
"../../src/index.js"
],
sourcesContent: [
"export default typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; ",
"import isBrowser from './isBrowser'; const timeoutDuration = (function(){ const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox']; for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) { if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) { return 1; } } return 0; }()); export function microtaskDebounce(fn) { let called = false return () => { if (called) { return } called = true window.Promise.resolve().then(() => { called = false fn() }) } } export function taskDebounce(fn) { let scheduled = false; return () => { if (!scheduled) { scheduled = true; setTimeout(() => { scheduled = false; fn(); }, timeoutDuration); } }; } const supportsMicroTasks = isBrowser && window.Promise /** * Create a debounced version of a method, that's asynchronously deferred * but called in the minimum time possible. * * @method * @memberof Popper.Utils * @argument {Function} fn * @returns {Function} */ export default (supportsMicroTasks ? microtaskDebounce : taskDebounce); ",
"/** * Check if the given variable is a function * @method * @memberof Popper.Utils * @argument {Any} functionToCheck - variable to check * @returns {Boolean} answer to: is a function? */ export default function isFunction(functionToCheck) { const getType = {}; return ( functionToCheck && getType.toString.call(functionToCheck) === '[object Function]' ); } ",
"/** * Get CSS computed property of the given element * @method * @memberof Popper.Utils * @argument {Eement} element * @argument {String} property */ export default function getStyleComputedProperty(element, property) { if (element.nodeType !== 1) { return []; } // NOTE: 1 DOM access here const window = element.ownerDocument.defaultView; const css = window.getComputedStyle(element, null); return property ? css[property] : css; } ",
"/** * Returns the parentNode or the host of the element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} parent */ export default function getParentNode(element) { if (element.nodeName === 'HTML') { return element; } return element.parentNode || element.host; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Returns the scrolling parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} scroll parent */ export default function getScrollParent(element) { // Return body, `getScroll` will take care to get the correct `scrollTop` from it if (!element) { return document.body } switch (element.nodeName) { case 'HTML': case 'BODY': return element.ownerDocument.body case '#document': return element.body } // Firefox want us to check `-x` and `-y` variations as well const { overflow, overflowX, overflowY } = getStyleComputedProperty(element); if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) { return element; } return getScrollParent(getParentNode(element)); } ",
"/** * Returns the reference node of the reference object, or the reference object itself. * @method * @memberof Popper.Utils * @param {Element|Object} reference - the reference element (the popper will be relative to this) * @returns {Element} parent */ export default function getReferenceNode(reference) { return reference && reference.referenceNode ? reference.referenceNode : reference; } ",
"import isBrowser from './isBrowser'; const isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode); const isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent); /** * Determines if the browser is Internet Explorer * @method * @memberof Popper.Utils * @param {Number} version to check * @returns {Boolean} isIE */ export default function isIE(version) { if (version === 11) { return isIE11; } if (version === 10) { return isIE10; } return isIE11 || isIE10; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Returns the offset parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} offset parent */ export default function getOffsetParent(element) { if (!element) { return document.documentElement; } const noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here let offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent while (offsetParent === noOffsetParent && element.nextElementSibling) { offsetParent = (element = element.nextElementSibling).offsetParent; } const nodeName = offsetParent && offsetParent.nodeName; if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') { return element ? element.ownerDocument.documentElement : document.documentElement; } // .offsetParent will return the closest TH, TD or TABLE in case // no offsetParent is present, I hate this job... if ( ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static' ) { return getOffsetParent(offsetParent); } return offsetParent; } ",
"import getOffsetParent from './getOffsetParent'; export default function isOffsetContainer(element) { const { nodeName } = element; if (nodeName === 'BODY') { return false; } return ( nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element ); } ",
"/** * Finds the root node (document, shadowDOM root) of the given element * @method * @memberof Popper.Utils * @argument {Element} node * @returns {Element} root node */ export default function getRoot(node) { if (node.parentNode !== null) { return getRoot(node.parentNode); } return node; } ",
"import isOffsetContainer from './isOffsetContainer'; import getRoot from './getRoot'; import getOffsetParent from './getOffsetParent'; /** * Finds the offset parent common to the two provided nodes * @method * @memberof Popper.Utils * @argument {Element} element1 * @argument {Element} element2 * @returns {Element} common offset parent */ export default function findCommonOffsetParent(element1, element2) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) { return document.documentElement; } // Here we make sure to give as "start" the element that comes first in the DOM const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING; const start = order ? element1 : element2; const end = order ? element2 : element1; // Get common ancestor container const range = document.createRange(); range.setStart(start, 0); range.setEnd(end, 0); const { commonAncestorContainer } = range; // Both nodes are inside #document if ( (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer) || start.contains(end) ) { if (isOffsetContainer(commonAncestorContainer)) { return commonAncestorContainer; } return getOffsetParent(commonAncestorContainer); } // one of the nodes is inside shadowDOM, find which one const element1root = getRoot(element1); if (element1root.host) { return findCommonOffsetParent(element1root.host, element2); } else { return findCommonOffsetParent(element1, getRoot(element2).host); } } ",
"/** * Gets the scroll value of the given element in the given side (top and left) * @method * @memberof Popper.Utils * @argument {Element} element * @argument {String} side `top` or `left` * @returns {number} amount of scrolled pixels */ export default function getScroll(element, side = 'top') { const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft'; const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { const html = element.ownerDocument.documentElement; const scrollingElement = element.ownerDocument.scrollingElement || html; return scrollingElement[upperSide]; } return element[upperSide]; } ",
"import getScroll from './getScroll'; /* * Sum or subtract the element scroll values (left and top) from a given rect object * @method * @memberof Popper.Utils * @param {Object} rect - Rect object you want to change * @param {HTMLElement} element - The element from the function reads the scroll values * @param {Boolean} subtract - set to true if you want to subtract the scroll values * @return {Object} rect - The modifier rect object */ export default function includeScroll(rect, element, subtract = false) { const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); const modifier = subtract ? -1 : 1; rect.top += scrollTop * modifier; rect.bottom += scrollTop * modifier; rect.left += scrollLeft * modifier; rect.right += scrollLeft * modifier; return rect; } ",
"/* * Helper to detect borders of a given element * @method * @memberof Popper.Utils * @param {CSSStyleDeclaration} styles * Result of `getStyleComputedProperty` on the given element * @param {String} axis - `x` or `y` * @return {number} borders - The borders size of the given axis */ export default function getBordersSize(styles, axis) { const sideA = axis === 'x' ? 'Left' : 'Top'; const sideB = sideA === 'Left' ? 'Right' : 'Bottom'; return ( parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]) ); } ",
"import isIE from './isIE'; function getSize(axis, body, html, computedStyle) { return Math.max( body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE(10) ? (parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`])) : 0 ); } export default function getWindowSizes(document) { const body = document.body; const html = document.documentElement; const computedStyle = isIE(10) && getComputedStyle(html); return { height: getSize('Height', body, html, computedStyle), width: getSize('Width', body, html, computedStyle), }; } ",
"/** * Given element offsets, generate an output similar to getBoundingClientRect * @method * @memberof Popper.Utils * @argument {Object} offsets * @returns {Object} ClientRect like output */ export default function getClientRect(offsets) { return { ...offsets, right: offsets.left + offsets.width, bottom: offsets.top + offsets.height, }; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getBordersSize from './getBordersSize'; import getWindowSizes from './getWindowSizes'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; import isIE from './isIE'; /** * Get bounding client rect of given element * @method * @memberof Popper.Utils * @param {HTMLElement} element * @return {Object} client rect */ export default function getBoundingClientRect(element) { let rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't // considered in DOM in some circumstances... // This isn't reproducible in IE10 compatibility mode of IE11 try { if (isIE(10)) { rect = element.getBoundingClientRect(); const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); rect.top += scrollTop; rect.left += scrollLeft; rect.bottom += scrollTop; rect.right += scrollLeft; } else { rect = element.getBoundingClientRect(); } } catch(e){} const result = { left: rect.left, top: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top, }; // subtract scrollbar size from sizes const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {}; const width = sizes.width || element.clientWidth || result.width; const height = sizes.height || element.clientHeight || result.height; let horizScrollbar = element.offsetWidth - width; let vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border` // we make this check conditional for performance reasons if (horizScrollbar || vertScrollbar) { const styles = getStyleComputedProperty(element); horizScrollbar -= getBordersSize(styles, 'x'); vertScrollbar -= getBordersSize(styles, 'y'); result.width -= horizScrollbar; result.height -= vertScrollbar; } return getClientRect(result); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import includeScroll from './includeScroll'; import getScrollParent from './getScrollParent'; import getBoundingClientRect from './getBoundingClientRect'; import runIsIE from './isIE'; import getClientRect from './getClientRect'; export default function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) { const isIE10 = runIsIE(10); const isHTML = parent.nodeName === 'HTML'; const childrenRect = getBoundingClientRect(children); const parentRect = getBoundingClientRect(parent); const scrollParent = getScrollParent(children); const styles = getStyleComputedProperty(parent); const borderTopWidth = parseFloat(styles.borderTopWidth); const borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc if(fixedPosition && isHTML) { parentRect.top = Math.max(parentRect.top, 0); parentRect.left = Math.max(parentRect.left, 0); } let offsets = getClientRect({ top: childrenRect.top - parentRect.top - borderTopWidth, left: childrenRect.left - parentRect.left - borderLeftWidth, width: childrenRect.width, height: childrenRect.height, }); offsets.marginTop = 0; offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent // we do this only on HTML because it's the only element that behaves // differently when margins are applied to it. The margins are included in // the box of the documentElement, in the other cases not. if (!isIE10 && isHTML) { const marginTop = parseFloat(styles.marginTop); const marginLeft = parseFloat(styles.marginLeft); offsets.top -= borderTopWidth - marginTop; offsets.bottom -= borderTopWidth - marginTop; offsets.left -= borderLeftWidth - marginLeft; offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them offsets.marginTop = marginTop; offsets.marginLeft = marginLeft; } if ( isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY' ) { offsets = includeScroll(offsets, parent); } return offsets; } ",
"import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; export default function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) { const html = element.ownerDocument.documentElement; const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html); const width = Math.max(html.clientWidth, window.innerWidth || 0); const height = Math.max(html.clientHeight, window.innerHeight || 0); const scrollTop = !excludeScroll ? getScroll(html) : 0; const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0; const offset = { top: scrollTop - relativeOffset.top + relativeOffset.marginTop, left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft, width, height, }; return getClientRect(offset); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Check if the given element is fixed or is inside a fixed parent * @method * @memberof Popper.Utils * @argument {Element} element * @argument {Element} customContainer * @returns {Boolean} answer to "isFixed?" */ export default function isFixed(element) { const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { return false; } if (getStyleComputedProperty(element, 'position') === 'fixed') { return true; } const parentNode = getParentNode(element); if (!parentNode) { return false; } return isFixed(parentNode); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Finds the first parent of an element that has a transformed property defined * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} first transformed parent or documentElement */ export default function getFixedPositionOffsetParent(element) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element || !element.parentElement || isIE()) { return document.documentElement; } let el = element.parentElement; while (el && getStyleComputedProperty(el, 'transform') === 'none') { el = el.parentElement; } return el || document.documentElement; } ",
"import getScrollParent from './getScrollParent'; import getParentNode from './getParentNode'; import getReferenceNode from './getReferenceNode'; import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getViewportOffsetRectRelativeToArtbitraryNode from './getViewportOffsetRectRelativeToArtbitraryNode'; import getWindowSizes from './getWindowSizes'; import isFixed from './isFixed'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; /** * Computed the boundaries limits and return them * @method * @memberof Popper.Utils * @param {HTMLElement} popper * @param {HTMLElement} reference * @param {number} padding * @param {HTMLElement} boundariesElement - Element used to define the boundaries * @param {Boolean} fixedPosition - Is in fixed position mode * @returns {Object} Coordinates of the boundaries */ export default function getBoundaries( popper, reference, padding, boundariesElement, fixedPosition = false ) { // NOTE: 1 DOM access here let boundaries = { top: 0, left: 0 }; const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case if (boundariesElement === 'viewport' ) { boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition); } else { // Handle other cases based on DOM element used as boundaries let boundariesNode; if (boundariesElement === 'scrollParent') { boundariesNode = getScrollParent(getParentNode(reference)); if (boundariesNode.nodeName === 'BODY') { boundariesNode = popper.ownerDocument.documentElement; } } else if (boundariesElement === 'window') { boundariesNode = popper.ownerDocument.documentElement; } else { boundariesNode = boundariesElement; } const offsets = getOffsetRectRelativeToArbitraryNode( boundariesNode, offsetParent, fixedPosition ); // In case of HTML, we need a different computation if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) { const { height, width } = getWindowSizes(popper.ownerDocument); boundaries.top += offsets.top - offsets.marginTop; boundaries.bottom = height + offsets.top; boundaries.left += offsets.left - offsets.marginLeft; boundaries.right = width + offsets.left; } else { // for all the other DOM elements, this one is good boundaries = offsets; } } // Add paddings padding = padding || 0; const isPaddingNumber = typeof padding === 'number'; boundaries.left += isPaddingNumber ? padding : padding.left || 0; boundaries.top += isPaddingNumber ? padding : padding.top || 0; boundaries.right -= isPaddingNumber ? padding : padding.right || 0; boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0; return boundaries; } ",
"import getBoundaries from '../utils/getBoundaries'; function getArea({ width, height }) { return width * height; } /** * Utility used to transform the `auto` placement to the placement with more * available space. * @method * @memberof Popper.Utils * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeAutoPlacement( placement, refRect, popper, reference, boundariesElement, padding = 0 ) { if (placement.indexOf('auto') === -1) { return placement; } const boundaries = getBoundaries( popper, reference, padding, boundariesElement ); const rects = { top: { width: boundaries.width, height: refRect.top - boundaries.top, }, right: { width: boundaries.right - refRect.right, height: boundaries.height, }, bottom: { width: boundaries.width, height: boundaries.bottom - refRect.bottom, }, left: { width: refRect.left - boundaries.left, height: boundaries.height, }, }; const sortedAreas = Object.keys(rects) .map(key => ({ key, ...rects[key], area: getArea(rects[key]), })) .sort((a, b) => b.area - a.area); const filteredAreas = sortedAreas.filter( ({ width, height }) => width >= popper.clientWidth && height >= popper.clientHeight ); const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key; const variation = placement.split('-')[1]; return computedPlacement + (variation ? `-${variation}` : ''); } ",
"import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; import getReferenceNode from './getReferenceNode'; /** * Get offsets to the reference element * @method * @memberof Popper.Utils * @param {Object} state * @param {Element} popper - the popper element * @param {Element} reference - the reference element (the popper will be relative to this) * @param {Element} fixedPosition - is in fixed position mode * @returns {Object} An object containing the offsets which will be applied to the popper */ export default function getReferenceOffsets(state, popper, reference, fixedPosition = null) { const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition); } ",
"/** * Get the outer sizes of the given element (offset size + margins) * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Object} object containing width and height properties */ export default function getOuterSizes(element) { const window = element.ownerDocument.defaultView; const styles = window.getComputedStyle(element); const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0); const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0); const result = { width: element.offsetWidth + y, height: element.offsetHeight + x, }; return result; } ",
"/** * Get the opposite placement of the given one * @method * @memberof Popper.Utils * @argument {String} placement * @returns {String} flipped placement */ export default function getOppositePlacement(placement) { const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; return placement.replace(/left|right|bottom|top/g, matched => hash[matched]); } ",
"import getOuterSizes from './getOuterSizes'; import getOppositePlacement from './getOppositePlacement'; /** * Get offsets to the popper * @method * @memberof Popper.Utils * @param {Object} position - CSS position the Popper will get applied * @param {HTMLElement} popper - the popper element * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this) * @param {String} placement - one of the valid placement options * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper */ export default function getPopperOffsets(popper, referenceOffsets, placement) { placement = placement.split('-')[0]; // Get popper node sizes const popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object const popperOffsets = { width: popperRect.width, height: popperRect.height, }; // depending by the popper placement we have to compute its offsets slightly differently const isHoriz = ['right', 'left'].indexOf(placement) !== -1; const mainSide = isHoriz ? 'top' : 'left'; const secondarySide = isHoriz ? 'left' : 'top'; const measurement = isHoriz ? 'height' : 'width'; const secondaryMeasurement = !isHoriz ? 'height' : 'width'; popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2; if (placement === secondarySide) { popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement]; } else { popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)]; } return popperOffsets; } ",
"/** * Mimics the `find` method of Array * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function find(arr, check) { // use native find if supported if (Array.prototype.find) { return arr.find(check); } // use `filter` to obtain the same behavior of `find` return arr.filter(check)[0]; } ",
"import find from './find'; /** * Return the index of the matching object * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function findIndex(arr, prop, value) { // use native findIndex if supported if (Array.prototype.findIndex) { return arr.findIndex(cur => cur[prop] === value); } // use `find` + `indexOf` if `findIndex` isn't supported const match = find(arr, obj => obj[prop] === value); return arr.indexOf(match); } ",
"import isFunction from './isFunction'; import findIndex from './findIndex'; import getClientRect from '../utils/getClientRect'; /** * Loop trough the list of modifiers and run them in order, * each of them will then edit the data object. * @method * @memberof Popper.Utils * @param {dataObject} data * @param {Array} modifiers * @param {String} ends - Optional modifier name used as stopper * @returns {dataObject} */ export default function runModifiers(modifiers, data, ends) { const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends)); modifiersToRun.forEach(modifier => { if (modifier['function']) { // eslint-disable-line dot-notation console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); } const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation if (modifier.enabled && isFunction(fn)) { // Add properties to offsets to make them a complete clientRect object // we do this before each modifier to make sure the previous one doesn't // mess with these values data.offsets.popper = getClientRect(data.offsets.popper); data.offsets.reference = getClientRect(data.offsets.reference); data = fn(data, modifier); } }); return data; } ",
"import computeAutoPlacement from '../utils/computeAutoPlacement'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; /** * Updates the position of the popper, computing the new offsets and applying * the new style.<br /> * Prefer `scheduleUpdate` over `update` because of performance reasons. * @method * @memberof Popper */ export default function update() { // if popper is destroyed, don't perform any further update if (this.state.isDestroyed) { return; } let data = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: false, offsets: {}, }; // compute reference element offsets data.offsets.reference = getReferenceOffsets( this.state, this.popper, this.reference, this.options.positionFixed ); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value data.placement = computeAutoPlacement( this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding ); // store the computed placement inside `originalPlacement` data.originalPlacement = data.placement; data.positionFixed = this.options.positionFixed; // compute the popper offsets data.offsets.popper = getPopperOffsets( this.popper, data.offsets.reference, data.placement ); data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback // the other ones will call `onUpdate` callback if (!this.state.isCreated) { this.state.isCreated = true; this.options.onCreate(data); } else { this.options.onUpdate(data); } } ",
"/** * Helper used to know if the given modifier is enabled. * @method * @memberof Popper.Utils * @returns {Boolean} */ export default function isModifierEnabled(modifiers, modifierName) { return modifiers.some( ({ name, enabled }) => enabled && name === modifierName ); } ",
"/** * Get the prefixed supported property name * @method * @memberof Popper.Utils * @argument {String} property (camelCase) * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix) */ export default function getSupportedPropertyName(property) { const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O']; const upperProp = property.charAt(0).toUpperCase() + property.slice(1); for (let i = 0; i < prefixes.length; i++) { const prefix = prefixes[i]; const toCheck = prefix ? `${prefix}${upperProp}` : property; if (typeof document.body.style[toCheck] !== 'undefined') { return toCheck; } } return null; } ",
"import isModifierEnabled from '../utils/isModifierEnabled'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * Destroys the popper. * @method * @memberof Popper */ export default function destroy() { this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled if (isModifierEnabled(this.modifiers, 'applyStyle')) { this.popper.removeAttribute('x-placement'); this.popper.style.position = ''; this.popper.style.top = ''; this.popper.style.left = ''; this.popper.style.right = ''; this.popper.style.bottom = ''; this.popper.style.willChange = ''; this.popper.style[getSupportedPropertyName('transform')] = ''; } this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy // do not use `remove` because IE11 doesn't support it if (this.options.removeOnDestroy) { this.popper.parentNode.removeChild(this.popper); } return this; } ",
"/** * Get the window associated with the element * @argument {Element} element * @returns {Window} */ export default function getWindow(element) { const ownerDocument = element.ownerDocument; return ownerDocument ? ownerDocument.defaultView : window; } ",
"import getScrollParent from './getScrollParent'; import getWindow from './getWindow'; function attachToScrollParents(scrollParent, event, callback, scrollParents) { const isBody = scrollParent.nodeName === 'BODY'; const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent; target.addEventListener(event, callback, { passive: true }); if (!isBody) { attachToScrollParents( getScrollParent(target.parentNode), event, callback, scrollParents ); } scrollParents.push(target); } /** * Setup needed event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function setupEventListeners( reference, options, state, updateBound ) { // Resize event listener on window state.updateBound = updateBound; getWindow(reference).addEventListener('resize', state.updateBound, { passive: true }); // Scroll event listener on scroll parents const scrollElement = getScrollParent(reference); attachToScrollParents( scrollElement, 'scroll', state.updateBound, state.scrollParents ); state.scrollElement = scrollElement; state.eventsEnabled = true; return state; } ",
"import setupEventListeners from '../utils/setupEventListeners'; /** * It will add resize/scroll events and start recalculating * position of the popper element when they are triggered. * @method * @memberof Popper */ export default function enableEventListeners() { if (!this.state.eventsEnabled) { this.state = setupEventListeners( this.reference, this.options, this.state, this.scheduleUpdate ); } } ",
"import getWindow from './getWindow'; /** * Remove event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function removeEventListeners(reference, state) { // Remove resize event listener on window getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents state.scrollParents.forEach(target => { target.removeEventListener('scroll', state.updateBound); }); // Reset state state.updateBound = null; state.scrollParents = []; state.scrollElement = null; state.eventsEnabled = false; return state; } ",
"import removeEventListeners from '../utils/removeEventListeners'; /** * It will remove resize/scroll events and won't recalculate popper position * when they are triggered. It also won't trigger `onUpdate` callback anymore, * unless you call `update` method manually. * @method * @memberof Popper */ export default function disableEventListeners() { if (this.state.eventsEnabled) { cancelAnimationFrame(this.scheduleUpdate); this.state = removeEventListeners(this.reference, this.state); } } ",
"/** * Tells if a given input is a number * @method * @memberof Popper.Utils * @param {*} input to check * @return {Boolean} */ export default function isNumeric(n) { return n !== '' && !isNaN(parseFloat(n)) && isFinite(n); } ",
"import isNumeric from './isNumeric'; /** * Set the style to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the style to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setStyles(element, styles) { Object.keys(styles).forEach(prop => { let unit = ''; // add unit if the value is numeric and is one of the following if ( ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop]) ) { unit = 'px'; } element.style[prop] = styles[prop] + unit; }); } ",
"/** * Set the attributes to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the attributes to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setAttributes(element, attributes) { Object.keys(attributes).forEach(function(prop) { const value = attributes[prop]; if (value !== false) { element.setAttribute(prop, attributes[prop]); } else { element.removeAttribute(prop); } }); } ",
"import setStyles from '../utils/setStyles'; import setAttributes from '../utils/setAttributes'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import computeAutoPlacement from '../utils/computeAutoPlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} data.styles - List of style properties - values to apply to popper element * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element * @argument {Object} options - Modifiers configuration and options * @returns {Object} The same data object */ export default function applyStyle(data) { // any property present in `data.styles` will be applied to the popper, // in this way we can make the 3rd party modifiers add custom styles to it // Be aware, modifiers could override the properties defined in the previous // lines of this modifier! setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper, // they will be set as HTML attributes of the element setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties if (data.arrowElement && Object.keys(data.arrowStyles).length) { setStyles(data.arrowElement, data.arrowStyles); } return data; } /** * Set the x-placement attribute before everything else because it could be used * to add margins to the popper margins needs to be calculated to get the * correct popper offsets. * @method * @memberof Popper.modifiers * @param {HTMLElement} reference - The reference element used to position the popper * @param {HTMLElement} popper - The HTML element used as popper * @param {Object} options - Popper.js options */ export function applyStyleOnLoad( reference, popper, options, modifierOptions, state ) { // compute reference element offsets const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value const placement = computeAutoPlacement( options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding ); popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because // without the position applied we can't guarantee correct computations setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' }); return options; } ",
"/** * @function * @memberof Popper.Utils * @argument {Object} data - The data object generated by `update` method * @argument {Boolean} shouldRound - If the offsets should be rounded at all * @returns {Object} The popper's position offsets rounded * * The tale of pixel-perfect positioning. It's still not 100% perfect, but as * good as it can be within reason. * Discussion here: https://github.com/FezVrasta/popper.js/pull/715 * * Low DPI screens cause a popper to be blurry if not using full pixels (Safari * as well on High DPI screens). * * Firefox prefers no rounding for positioning and does not have blurriness on * high DPI screens. * * Only horizontal placement and left/right values need to be considered. */ export default function getRoundedOffsets(data, shouldRound) { const { popper, reference } = data.offsets; const { round, floor } = Math; const noRound = v => v; const referenceWidth = round(reference.width); const popperWidth = round(popper.width); const isVertical = ['left', 'right'].indexOf(data.placement) !== -1; const isVariation = data.placement.indexOf('-') !== -1; const sameWidthParity = referenceWidth % 2 === popperWidth % 2; const bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1; const horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor; const verticalToInteger = !shouldRound ? noRound : round; return { left: horizontalToInteger( bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left ), top: verticalToInteger(popper.top), bottom: verticalToInteger(popper.bottom), right: horizontalToInteger(popper.right), }; } ",
"import getSupportedPropertyName from '../utils/getSupportedPropertyName'; import find from '../utils/find'; import getOffsetParent from '../utils/getOffsetParent'; import getBoundingClientRect from '../utils/getBoundingClientRect'; import getRoundedOffsets from '../utils/getRoundedOffsets'; import isBrowser from '../utils/isBrowser'; const isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent); /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeStyle(data, options) { const { x, y } = options; const { popper } = data.offsets; // Remove this legacy support in Popper.js v2 const legacyGpuAccelerationOption = find( data.instance.modifiers, modifier => modifier.name === 'applyStyle' ).gpuAcceleration; if (legacyGpuAccelerationOption !== undefined) { console.warn( 'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!' ); } const gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration; const offsetParent = getOffsetParent(data.instance.popper); const offsetParentRect = getBoundingClientRect(offsetParent); // Styles const styles = { position: popper.position, }; const offsets = getRoundedOffsets( data, window.devicePixelRatio < 2 || !isFirefox ); const sideA = x === 'bottom' ? 'top' : 'bottom'; const sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported, // we use `translate3d` to apply the position to the popper we // automatically use the supported prefixed version if needed const prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?) // If the content of the popper grows once it's been positioned, it // may happen that the popper gets misplaced because of the new content // overflowing its reference element // To avoid this problem, we provide two options (x and y), which allow // the consumer to define the offset origin. // If we position a popper on top of a reference element, we can set // `x` to `top` to make the popper grow towards its top instead of // its bottom. let left, top; if (sideA === 'bottom') { // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar) // and not the bottom of the html element if (offsetParent.nodeName === 'HTML') { top = -offsetParent.clientHeight + offsets.bottom; } else { top = -offsetParentRect.height + offsets.bottom; } } else { top = offsets.top; } if (sideB === 'right') { if (offsetParent.nodeName === 'HTML') { left = -offsetParent.clientWidth + offsets.right; } else { left = -offsetParentRect.width + offsets.right; } } else { left = offsets.left; } if (gpuAcceleration && prefixedProperty) { styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`; styles[sideA] = 0; styles[sideB] = 0; styles.willChange = 'transform'; } else { // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties const invertTop = sideA === 'bottom' ? -1 : 1; const invertLeft = sideB === 'right' ? -1 : 1; styles[sideA] = top * invertTop; styles[sideB] = left * invertLeft; styles.willChange = `${sideA}, ${sideB}`; } // Attributes const attributes = { 'x-placement': data.placement, }; // Update `data` attributes, styles and arrowStyles data.attributes = { ...attributes, ...data.attributes }; data.styles = { ...styles, ...data.styles }; data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles }; return data; } ",
"import find from './find'; /** * Helper used to know if the given modifier depends from another one.<br /> * It checks if the needed modifier is listed and enabled. * @method * @memberof Popper.Utils * @param {Array} modifiers - list of modifiers * @param {String} requestingName - name of requesting modifier * @param {String} requestedName - name of requested modifier * @returns {Boolean} */ export default function isModifierRequired( modifiers, requestingName, requestedName ) { const requesting = find(modifiers, ({ name }) => name === requestingName); const isRequired = !!requesting && modifiers.some(modifier => { return ( modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order ); }); if (!isRequired) { const requesting = `\`${requestingName}\``; const requested = `\`${requestedName}\``; console.warn( `${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!` ); } return isRequired; } ",
"import getClientRect from '../utils/getClientRect'; import getOuterSizes from '../utils/getOuterSizes'; import isModifierRequired from '../utils/isModifierRequired'; import getStyleComputedProperty from '../utils/getStyleComputedProperty'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function arrow(data, options) { // arrow depends on keepTogether in order to work if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) { return data; } let arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector if (typeof arrowElement === 'string') { arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier if (!arrowElement) { return data; } } else { // if the arrowElement isn't a query selector we must check that the // provided DOM node is child of its popper node if (!data.instance.popper.contains(arrowElement)) { console.warn( 'WARNING: `arrow.element` must be child of its popper element!' ); return data; } } const placement = data.placement.split('-')[0]; const { popper, reference } = data.offsets; const isVertical = ['left', 'right'].indexOf(placement) !== -1; const len = isVertical ? 'height' : 'width'; const sideCapitalized = isVertical ? 'Top' : 'Left'; const side = sideCapitalized.toLowerCase(); const altSide = isVertical ? 'left' : 'top'; const opSide = isVertical ? 'bottom' : 'right'; const arrowElementSize = getOuterSizes(arrowElement)[len]; // // extends keepTogether behavior making sure the popper and its // reference have enough pixels in conjunction // // top/left side if (reference[opSide] - arrowElementSize < popper[side]) { data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize); } // bottom/right side if (reference[side] + arrowElementSize > popper[opSide]) { data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]; } data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper const center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets // take popper margin in account because we don't have this info available const css = getStyleComputedProperty(data.instance.popper); const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`]); const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`]); let sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0); data.arrowElement = arrowElement; data.offsets.arrow = { [side]: Math.round(sideValue), [altSide]: '', // make sure to unset any eventual altSide value from the DOM node }; return data; } ",
"/** * Get the opposite placement variation of the given one * @method * @memberof Popper.Utils * @argument {String} placement variation * @returns {String} flipped placement variation */ export default function getOppositeVariation(variation) { if (variation === 'end') { return 'start'; } else if (variation === 'start') { return 'end'; } return variation; } ",
"/** * List of accepted placements to use as values of the `placement` option.<br /> * Valid placements are: * - `auto` * - `top` * - `right` * - `bottom` * - `left` * * Each placement can have a variation from this list: * - `-start` * - `-end` * * Variations are interpreted easily if you think of them as the left to right * written languages. Horizontally (`top` and `bottom`), `start` is left and `end` * is right.<br /> * Vertically (`left` and `right`), `start` is top and `end` is bottom. * * Some valid examples are: * - `top-end` (on top of reference, right aligned) * - `right-start` (on right of reference, top aligned) * - `bottom` (on bottom, centered) * - `auto-end` (on the side with more space available, alignment depends by placement) * * @static * @type {Array} * @enum {String} * @readonly * @method placements * @memberof Popper */ export default [ 'auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start', ]; ",
"import placements from '../methods/placements'; // Get rid of `auto` `auto-start` and `auto-end` const validPlacements = placements.slice(3); /** * Given an initial placement, returns all the subsequent placements * clockwise (or counter-clockwise). * * @method * @memberof Popper.Utils * @argument {String} placement - A valid placement (it accepts variations) * @argument {Boolean} counter - Set to true to walk the placements counterclockwise * @returns {Array} placements including their variations */ export default function clockwise(placement, counter = false) { const index = validPlacements.indexOf(placement); const arr = validPlacements .slice(index + 1) .concat(validPlacements.slice(0, index)); return counter ? arr.reverse() : arr; } ",
"import getOppositePlacement from '../utils/getOppositePlacement'; import getOppositeVariation from '../utils/getOppositeVariation'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; import getBoundaries from '../utils/getBoundaries'; import isModifierEnabled from '../utils/isModifierEnabled'; import clockwise from '../utils/clockwise'; const BEHAVIORS = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise', }; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function flip(data, options) { // if `inner` modifier is enabled, we can't use the `flip` modifier if (isModifierEnabled(data.instance.modifiers, 'inner')) { return data; } if (data.flipped && data.placement === data.originalPlacement) { // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides return data; } const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed ); let placement = data.placement.split('-')[0]; let placementOpposite = getOppositePlacement(placement); let variation = data.placement.split('-')[1] || ''; let flipOrder = []; switch (options.behavior) { case BEHAVIORS.FLIP: flipOrder = [placement, placementOpposite]; break; case BEHAVIORS.CLOCKWISE: flipOrder = clockwise(placement); break; case BEHAVIORS.COUNTERCLOCKWISE: flipOrder = clockwise(placement, true); break; default: flipOrder = options.behavior; } flipOrder.forEach((step, index) => { if (placement !== step || flipOrder.length === index + 1) { return data; } placement = data.placement.split('-')[0]; placementOpposite = getOppositePlacement(placement); const popperOffsets = data.offsets.popper; const refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here const floor = Math.floor; const overlapsRef = (placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left)) || (placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right)) || (placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top)) || (placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom)); const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left); const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right); const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top); const overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom); const overflowsBoundaries = (placement === 'left' && overflowsLeft) || (placement === 'right' && overflowsRight) || (placement === 'top' && overflowsTop) || (placement === 'bottom' && overflowsBottom); // flip the variation if required const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries const flippedVariationByRef = !!options.flipVariations && ((isVertical && variation === 'start' && overflowsLeft) || (isVertical && variation === 'end' && overflowsRight) || (!isVertical && variation === 'start' && overflowsTop) || (!isVertical && variation === 'end' && overflowsBottom)); // flips variation if popper content overflows boundaries const flippedVariationByContent = !!options.flipVariationsByContent && ((isVertical && variation === 'start' && overflowsRight) || (isVertical && variation === 'end' && overflowsLeft) || (!isVertical && variation === 'start' && overflowsBottom) || (!isVertical && variation === 'end' && overflowsTop)); const flippedVariation = flippedVariationByRef || flippedVariationByContent; if (overlapsRef || overflowsBoundaries || flippedVariation) { // this boolean to detect any flip loop data.flipped = true; if (overlapsRef || overflowsBoundaries) { placement = flipOrder[index + 1]; } if (flippedVariation) { variation = getOppositeVariation(variation); } data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with // any additional property we may add in the future data.offsets.popper = { ...data.offsets.popper, ...getPopperOffsets( data.instance.popper, data.offsets.reference, data.placement ), }; data = runModifiers(data.instance.modifiers, data, 'flip'); } }); return data; } ",
"/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function keepTogether(data) { const { popper, reference } = data.offsets; const placement = data.placement.split('-')[0]; const floor = Math.floor; const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const side = isVertical ? 'right' : 'bottom'; const opSide = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; if (popper[side] < floor(reference[opSide])) { data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]; } if (popper[opSide] > floor(reference[side])) { data.offsets.popper[opSide] = floor(reference[side]); } return data; } ",
"import isNumeric from '../utils/isNumeric'; import getClientRect from '../utils/getClientRect'; import find from '../utils/find'; /** * Converts a string containing value + unit into a px value number * @function * @memberof {modifiers~offset} * @private * @argument {String} str - Value + unit string * @argument {String} measurement - `height` or `width` * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @returns {Number|String} * Value in pixels, or original string if no values were extracted */ export function toValue(str, measurement, popperOffsets, referenceOffsets) { // separate value from unit const split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const value = +split[1]; const unit = split[2]; // If it's not a number it's an operator, I guess if (!value) { return str; } if (unit.indexOf('%') === 0) { let element; switch (unit) { case '%p': element = popperOffsets; break; case '%': case '%r': default: element = referenceOffsets; } const rect = getClientRect(element); return rect[measurement] / 100 * value; } else if (unit === 'vh' || unit === 'vw') { // if is a vh or vw, we calculate the size based on the viewport let size; if (unit === 'vh') { size = Math.max( document.documentElement.clientHeight, window.innerHeight || 0 ); } else { size = Math.max( document.documentElement.clientWidth, window.innerWidth || 0 ); } return size / 100 * value; } else { // if is an explicit pixel unit, we get rid of the unit and keep the value // if is an implicit unit, it's px, and we return just the value return value; } } /** * Parse an `offset` string to extrapolate `x` and `y` numeric offsets. * @function * @memberof {modifiers~offset} * @private * @argument {String} offset * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @argument {String} basePlacement * @returns {Array} a two cells array with x and y offsets in numbers */ export function parseOffset( offset, popperOffsets, referenceOffsets, basePlacement ) { const offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width // in this way the first offset will use an axis and the second one // will use the other one const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands // The regex addresses values with the plus or minus sign in front (+10, -20, etc) const fragments = offset.split(/(\+|\-)/).map(frag => frag.trim()); // Detect if the offset string contains a pair of values or a single one // they could be separated by comma or space const divider = fragments.indexOf( find(fragments, frag => frag.search(/,|\s/) !== -1) ); if (fragments[divider] && fragments[divider].indexOf(',') === -1) { console.warn( 'Offsets separated by white space(s) are deprecated, use a comma (,) instead.' ); } // If divider is found, we divide the list of values and operands to divide // them by ofset X and Y. const splitRegex = /\s*,\s*|\s+/; let ops = divider !== -1 ? [ fragments .slice(0, divider) .concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat( fragments.slice(divider + 1) ), ] : [fragments]; // Convert the values with units to absolute pixels to allow our computations ops = ops.map((op, index) => { // Most of the units rely on the orientation of the popper const measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width'; let mergeWithPrevious = false; return ( op // This aggregates any `+` or `-` sign that aren't considered operators // e.g.: 10 + +5 => [10, +, +5] .reduce((a, b) => { if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) { a[a.length - 1] = b; mergeWithPrevious = true; return a; } else if (mergeWithPrevious) { a[a.length - 1] += b; mergeWithPrevious = false; return a; } else { return a.concat(b); } }, []) // Here we convert the string values into number values (in px) .map(str => toValue(str, measurement, popperOffsets, referenceOffsets)) ); }); // Loop trough the offsets arrays and execute the operations ops.forEach((op, index) => { op.forEach((frag, index2) => { if (isNumeric(frag)) { offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1); } }); }); return offsets; } /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @argument {Number|String} options.offset=0 * The offset value as described in the modifier description * @returns {Object} The data object, properly modified */ export default function offset(data, { offset }) { const { placement, offsets: { popper, reference } } = data; const basePlacement = placement.split('-')[0]; let offsets; if (isNumeric(+offset)) { offsets = [+offset, 0]; } else { offsets = parseOffset(offset, popper, reference, basePlacement); } if (basePlacement === 'left') { popper.top += offsets[0]; popper.left -= offsets[1]; } else if (basePlacement === 'right') { popper.top += offsets[0]; popper.left += offsets[1]; } else if (basePlacement === 'top') { popper.left += offsets[0]; popper.top -= offsets[1]; } else if (basePlacement === 'bottom') { popper.left += offsets[0]; popper.top += offsets[1]; } data.popper = popper; return data; } ",
"import getOffsetParent from '../utils/getOffsetParent'; import getBoundaries from '../utils/getBoundaries'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function preventOverflow(data, options) { let boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to // go one step up and use the next offsetParent as reference to // avoid to make this modifier completely useless and look like broken if (data.instance.reference === boundariesElement) { boundariesElement = getOffsetParent(boundariesElement); } // NOTE: DOM access here // resets the popper's position so that the document size can be calculated excluding // the size of the popper element itself const transformProp = getSupportedPropertyName('transform'); const popperStyles = data.instance.popper.style; // assignment to help minification const { top, left, [transformProp]: transform } = popperStyles; popperStyles.top = ''; popperStyles.left = ''; popperStyles[transformProp] = ''; const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed ); // NOTE: DOM access here // restores the original style properties after the offsets have been computed popperStyles.top = top; popperStyles.left = left; popperStyles[transformProp] = transform; options.boundaries = boundaries; const order = options.priority; let popper = data.offsets.popper; const check = { primary(placement) { let value = popper[placement]; if ( popper[placement] < boundaries[placement] && !options.escapeWithReference ) { value = Math.max(popper[placement], boundaries[placement]); } return { [placement]: value }; }, secondary(placement) { const mainSide = placement === 'right' ? 'left' : 'top'; let value = popper[mainSide]; if ( popper[placement] > boundaries[placement] && !options.escapeWithReference ) { value = Math.min( popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height) ); } return { [mainSide]: value }; }, }; order.forEach(placement => { const side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary'; popper = { ...popper, ...check[side](placement) }; }); data.offsets.popper = popper; return data; } ",
"/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function shift(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier if (shiftvariation) { const { reference, popper } = data.offsets; const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1; const side = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; const shiftOffsets = { start: { [side]: reference[side] }, end: { [side]: reference[side] + reference[measurement] - popper[measurement], }, }; data.offsets.popper = { ...popper, ...shiftOffsets[shiftvariation] }; } return data; } ",
"import isModifierRequired from '../utils/isModifierRequired'; import find from '../utils/find'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function hide(data) { if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) { return data; } const refRect = data.offsets.reference; const bound = find( data.instance.modifiers, modifier => modifier.name === 'preventOverflow' ).boundaries; if ( refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left ) { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === true) { return data; } data.hide = true; data.attributes['x-out-of-boundaries'] = ''; } else { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === false) { return data; } data.hide = false; data.attributes['x-out-of-boundaries'] = false; } return data; } ",
"import getClientRect from '../utils/getClientRect'; import getOppositePlacement from '../utils/getOppositePlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function inner(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const { popper, reference } = data.offsets; const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1; const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1; popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0); data.placement = getOppositePlacement(placement); data.offsets.popper = getClientRect(popper); return data; } ",
"import applyStyle, { applyStyleOnLoad } from './applyStyle'; import computeStyle from './computeStyle'; import arrow from './arrow'; import flip from './flip'; import keepTogether from './keepTogether'; import offset from './offset'; import preventOverflow from './preventOverflow'; import shift from './shift'; import hide from './hide'; import inner from './inner'; /** * Modifier function, each modifier can have a function of this type assigned * to its `fn` property.<br /> * These functions will be called on each update, this means that you must * make sure they are performant enough to avoid performance bottlenecks. * * @function ModifierFn * @argument {dataObject} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {dataObject} The data object, properly modified */ /** * Modifiers are plugins used to alter the behavior of your poppers.<br /> * Popper.js uses a set of 9 modifiers to provide all the basic functionalities * needed by the library. * * Usually you don't want to override the `order`, `fn` and `onLoad` props. * All the other properties are configurations that could be tweaked. * @namespace modifiers */ export default { /** * Modifier used to shift the popper on the start or end of its reference * element.<br /> * It will read the variation of the `placement` property.<br /> * It can be one either `-end` or `-start`. * @memberof modifiers * @inner */ shift: { /** @prop {number} order=100 - Index used to define the order of execution */ order: 100, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: shift, }, /** * The `offset` modifier can shift your popper on both its axis. * * It accepts the following units: * - `px` or unit-less, interpreted as pixels * - `%` or `%r`, percentage relative to the length of the reference element * - `%p`, percentage relative to the length of the popper element * - `vw`, CSS viewport width unit * - `vh`, CSS viewport height unit * * For length is intended the main axis relative to the placement of the popper.<br /> * This means that if the placement is `top` or `bottom`, the length will be the * `width`. In case of `left` or `right`, it will be the `height`. * * You can provide a single value (as `Number` or `String`), or a pair of values * as `String` divided by a comma or one (or more) white spaces.<br /> * The latter is a deprecated method because it leads to confusion and will be * removed in v2.<br /> * Additionally, it accepts additions and subtractions between different units. * Note that multiplications and divisions aren't supported. * * Valid examples are: * ``` * 10 * '10%' * '10, 10' * '10%, 10' * '10 + 10%' * '10 - 5vh + 3%' * '-10px + 5vh, 5px - 6%' * ``` * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap * > with their reference element, unfortunately, you will have to disable the `flip` modifier. * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373). * * @memberof modifiers * @inner */ offset: { /** @prop {number} order=200 - Index used to define the order of execution */ order: 200, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: offset, /** @prop {Number|String} offset=0 * The offset value as described in the modifier description */ offset: 0, }, /** * Modifier used to prevent the popper from being positioned outside the boundary. * * A scenario exists where the reference itself is not within the boundaries.<br /> * We can say it has "escaped the boundaries"  or just "escaped".<br /> * In this case we need to decide whether the popper should either: * * - detach from the reference and remain "trapped" in the boundaries, or * - if it should ignore the boundary and "escape with its reference" * * When `escapeWithReference` is set to`true` and reference is completely * outside its boundaries, the popper will overflow (or completely leave) * the boundaries in order to remain attached to the edge of the reference. * * @memberof modifiers * @inner */ preventOverflow: { /** @prop {number} order=300 - Index used to define the order of execution */ order: 300, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: preventOverflow, /** * @prop {Array} [priority=['left','right','top','bottom']] * Popper will try to prevent overflow following these priorities by default, * then, it could overflow on the left and on top of the `boundariesElement` */ priority: ['left', 'right', 'top', 'bottom'], /** * @prop {number} padding=5 * Amount of pixel used to define a minimum distance between the boundaries * and the popper. This makes sure the popper always has a little padding * between the edges of its container */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='scrollParent' * Boundaries used by the modifier. Can be `scrollParent`, `window`, * `viewport` or any DOM element. */ boundariesElement: 'scrollParent', }, /** * Modifier used to make sure the reference and its popper stay near each other * without leaving any gap between the two. Especially useful when the arrow is * enabled and you want to ensure that it points to its reference element. * It cares only about the first axis. You can still have poppers with margin * between the popper and its reference element. * @memberof modifiers * @inner */ keepTogether: { /** @prop {number} order=400 - Index used to define the order of execution */ order: 400, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: keepTogether, }, /** * This modifier is used to move the `arrowElement` of the popper to make * sure it is positioned between the reference element and its popper element. * It will read the outer size of the `arrowElement` node to detect how many * pixels of conjunction are needed. * * It has no effect if no `arrowElement` is provided. * @memberof modifiers * @inner */ arrow: { /** @prop {number} order=500 - Index used to define the order of execution */ order: 500, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: arrow, /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */ element: '[x-arrow]', }, /** * Modifier used to flip the popper's placement when it starts to overlap its * reference element. * * Requires the `preventOverflow` modifier before it in order to work. * * **NOTE:** this modifier will interrupt the current update cycle and will * restart it if it detects the need to flip the placement. * @memberof modifiers * @inner */ flip: { /** @prop {number} order=600 - Index used to define the order of execution */ order: 600, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: flip, /** * @prop {String|Array} behavior='flip' * The behavior used to change the popper's placement. It can be one of * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid * placements (with optional variations) */ behavior: 'flip', /** * @prop {number} padding=5 * The popper will flip if it hits the edges of the `boundariesElement` */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='viewport' * The element which will define the boundaries of the popper position. * The popper will never be placed outside of the defined boundaries * (except if `keepTogether` is enabled) */ boundariesElement: 'viewport', /** * @prop {Boolean} flipVariations=false * The popper will switch placement variation between `-start` and `-end` when * the reference element overlaps its boundaries. * * The original placement should have a set variation. */ flipVariations: false, /** * @prop {Boolean} flipVariationsByContent=false * The popper will switch placement variation between `-start` and `-end` when * the popper element overlaps its reference boundaries. * * The original placement should have a set variation. */ flipVariationsByContent: false, }, /** * Modifier used to make the popper flow toward the inner of the reference element. * By default, when this modifier is disabled, the popper will be placed outside * the reference element. * @memberof modifiers * @inner */ inner: { /** @prop {number} order=700 - Index used to define the order of execution */ order: 700, /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */ enabled: false, /** @prop {ModifierFn} */ fn: inner, }, /** * Modifier used to hide the popper when its reference element is outside of the * popper boundaries. It will set a `x-out-of-boundaries` attribute which can * be used to hide with a CSS selector the popper when its reference is * out of boundaries. * * Requires the `preventOverflow` modifier before it in order to work. * @memberof modifiers * @inner */ hide: { /** @prop {number} order=800 - Index used to define the order of execution */ order: 800, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: hide, }, /** * Computes the style that will be applied to the popper element to gets * properly positioned. * * Note that this modifier will not touch the DOM, it just prepares the styles * so that `applyStyle` modifier can apply it. This separation is useful * in case you need to replace `applyStyle` with a custom implementation. * * This modifier has `850` as `order` value to maintain backward compatibility * with previous versions of Popper.js. Expect the modifiers ordering method * to change in future major versions of the library. * * @memberof modifiers * @inner */ computeStyle: { /** @prop {number} order=850 - Index used to define the order of execution */ order: 850, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: computeStyle, /** * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: true, /** * @prop {string} [x='bottom'] * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin. * Change this if your popper should grow in a direction different from `bottom` */ x: 'bottom', /** * @prop {string} [x='left'] * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin. * Change this if your popper should grow in a direction different from `right` */ y: 'right', }, /** * Applies the computed styles to the popper element. * * All the DOM manipulations are limited to this modifier. This is useful in case * you want to integrate Popper.js inside a framework or view library and you * want to delegate all the DOM manipulations to it. * * Note that if you disable this modifier, you must make sure the popper element * has its position set to `absolute` before Popper.js can do its work! * * Just disable this modifier and define your own to achieve the desired effect. * * @memberof modifiers * @inner */ applyStyle: { /** @prop {number} order=900 - Index used to define the order of execution */ order: 900, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: applyStyle, /** @prop {Function} */ onLoad: applyStyleOnLoad, /** * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: undefined, }, }; /** * The `dataObject` is an object containing all the information used by Popper.js. * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks. * @name dataObject * @property {Object} data.instance The Popper.js instance * @property {String} data.placement Placement applied to popper * @property {String} data.originalPlacement Placement originally defined on init * @property {Boolean} data.flipped True if popper has been flipped by flip modifier * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.boundaries Offsets of the popper boundaries * @property {Object} data.offsets The measurements of popper, reference and arrow elements * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0 */ ",
"import modifiers from '../modifiers/index'; /** * Default options provided to Popper.js constructor.<br /> * These can be overridden using the `options` argument of Popper.js.<br /> * To override an option, simply pass an object with the same * structure of the `options` object, as the 3rd argument. For example: * ``` * new Popper(ref, pop, { * modifiers: { * preventOverflow: { enabled: false } * } * }) * ``` * @type {Object} * @static * @memberof Popper */ export default { /** * Popper's placement. * @prop {Popper.placements} placement='bottom' */ placement: 'bottom', /** * Set this to true if you want popper to position it self in 'fixed' mode * @prop {Boolean} positionFixed=false */ positionFixed: false, /** * Whether events (resize, scroll) are initially enabled. * @prop {Boolean} eventsEnabled=true */ eventsEnabled: true, /** * Set to true if you want to automatically remove the popper when * you call the `destroy` method. * @prop {Boolean} removeOnDestroy=false */ removeOnDestroy: false, /** * Callback called when the popper is created.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onCreate} */ onCreate: () => {}, /** * Callback called when the popper is updated. This callback is not called * on the initialization/creation of the popper, but only on subsequent * updates.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onUpdate} */ onUpdate: () => {}, /** * List of modifiers used to modify the offsets before they are applied to the popper. * They provide most of the functionalities of Popper.js. * @prop {modifiers} */ modifiers, }; /** * @callback onCreate * @param {dataObject} data */ /** * @callback onUpdate * @param {dataObject} data */ ",
"// Utils import debounce from './utils/debounce'; import isFunction from './utils/isFunction'; // Methods import update from './methods/update'; import destroy from './methods/destroy'; import enableEventListeners from './methods/enableEventListeners'; import disableEventListeners from './methods/disableEventListeners'; import Defaults from './methods/defaults'; import placements from './methods/placements'; export default class Popper { /** * Creates a new Popper.js instance. * @class Popper * @param {Element|referenceObject} reference - The reference element used to position the popper * @param {Element} popper - The HTML / XML element used as the popper * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults) * @return {Object} instance - The generated Popper.js instance */ constructor(reference, popper, options = {}) { // make update() debounced, so that it only runs at most once-per-tick this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it this.options = { ...Popper.Defaults, ...options }; // init state this.state = { isDestroyed: false, isCreated: false, scrollParents: [], }; // get reference and popper elements (allow jQuery wrappers) this.reference = reference && reference.jquery ? reference[0] : reference; this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options this.options.modifiers = {}; Object.keys({ ...Popper.Defaults.modifiers, ...options.modifiers, }).forEach(name => { this.options.modifiers[name] = { // If it's a built-in modifier, use it as base ...(Popper.Defaults.modifiers[name] || {}), // If there are custom options, override and merge with default ones ...(options.modifiers ? options.modifiers[name] : {}), }; }); // Refactoring modifiers' list (Object => Array) this.modifiers = Object.keys(this.options.modifiers) .map(name => ({ name, ...this.options.modifiers[name], })) // sort the modifiers by order .sort((a, b) => a.order - b.order); // modifiers have the ability to execute arbitrary code when Popper.js get inited // such code is executed in the same order of its modifier // they could add new properties to their options configuration // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`! this.modifiers.forEach(modifierOptions => { if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) { modifierOptions.onLoad( this.reference, this.popper, this.options, modifierOptions, this.state ); } }); // fire the first update to position the popper in the right place this.update(); const eventsEnabled = this.options.eventsEnabled; if (eventsEnabled) { // setup event listeners, they will take care of update the position in specific situations this.enableEventListeners(); } this.state.eventsEnabled = eventsEnabled; } // We can't use class properties because they don't get listed in the // class prototype and break stuff like Sinon stubs update() { return update.call(this); } destroy() { return destroy.call(this); } enableEventListeners() { return enableEventListeners.call(this); } disableEventListeners() { return disableEventListeners.call(this); } /** * Schedules an update. It will run on the next UI update available. * @method scheduleUpdate * @memberof Popper */ scheduleUpdate = () => requestAnimationFrame(this.update); /** * Collection of utilities useful when writing custom modifiers. * Starting from version 1.7, this method is available only if you * include `popper-utils.js` before `popper.js`. * * **DEPRECATION**: This way to access PopperUtils is deprecated * and will be removed in v2! Use the PopperUtils module directly instead. * Due to the high instability of the methods contained in Utils, we can't * guarantee them to follow semver. Use them at your own risk! * @static * @private * @type {Object} * @deprecated since version 1.8 * @member Utils * @memberof Popper */ static Utils = (typeof window !== 'undefined' ? window : global).PopperUtils; static placements = placements; static Defaults = Defaults; } /** * The `referenceObject` is an object that provides an interface compatible with Popper.js * and lets you use it as replacement of a real DOM node.<br /> * You can use this method to position a popper relatively to a set of coordinates * in case you don't have a DOM node to use as reference. * * ``` * new Popper(referenceObject, popperNode); * ``` * * NB: This feature isn't supported in Internet Explorer 10. * @name referenceObject * @property {Function} data.getBoundingClientRect * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method. * @property {number} data.clientWidth * An ES6 getter that will return the width of the virtual reference element. * @property {number} data.clientHeight * An ES6 getter that will return the height of the virtual reference element. */ "
],
names: [
"window",
"document",
"navigator",
"timeoutDuration",
"longerTimeoutBrowsers",
"i",
"length",
"isBrowser",
"userAgent",
"indexOf",
"microtaskDebounce",
"fn",
"called",
"Promise",
"resolve",
"then",
"taskDebounce",
"scheduled",
"supportsMicroTasks",
"isFunction",
"functionToCheck",
"getType",
"toString",
"call",
"getStyleComputedProperty",
"element",
"property",
"nodeType",
"ownerDocument",
"defaultView",
"css",
"getComputedStyle",
"getParentNode",
"nodeName",
"parentNode",
"host",
"getScrollParent",
"body",
"overflow",
"overflowX",
"overflowY",
"test",
"getReferenceNode",
"reference",
"referenceNode",
"isIE11",
"MSInputMethodContext",
"documentMode",
"isIE10",
"isIE",
"version",
"getOffsetParent",
"documentElement",
"noOffsetParent",
"offsetParent",
"nextElementSibling",
"isOffsetContainer",
"firstElementChild",
"getRoot",
"node",
"findCommonOffsetParent",
"element1",
"element2",
"order",
"compareDocumentPosition",
"Node",
"DOCUMENT_POSITION_FOLLOWING",
"start",
"end",
"range",
"createRange",
"setStart",
"setEnd",
"commonAncestorContainer",
"contains",
"element1root",
"getScroll",
"side",
"upperSide",
"html",
"scrollingElement",
"includeScroll",
"rect",
"subtract",
"scrollTop",
"scrollLeft",
"modifier",
"top",
"bottom",
"left",
"right",
"getBordersSize",
"styles",
"axis",
"sideA",
"sideB",
"parseFloat",
"getSize",
"computedStyle",
"Math",
"max",
"parseInt",
"getWindowSizes",
"getClientRect",
"offsets",
"width",
"height",
"getBoundingClientRect",
"e",
"result",
"sizes",
"clientWidth",
"clientHeight",
"horizScrollbar",
"offsetWidth",
"vertScrollbar",
"offsetHeight",
"getOffsetRectRelativeToArbitraryNode",
"children",
"parent",
"fixedPosition",
"runIsIE",
"isHTML",
"childrenRect",
"parentRect",
"scrollParent",
"borderTopWidth",
"borderLeftWidth",
"marginTop",
"marginLeft",
"getViewportOffsetRectRelativeToArtbitraryNode",
"excludeScroll",
"relativeOffset",
"innerWidth",
"innerHeight",
"offset",
"isFixed",
"getFixedPositionOffsetParent",
"parentElement",
"el",
"getBoundaries",
"popper",
"padding",
"boundariesElement",
"boundaries",
"boundariesNode",
"isPaddingNumber",
"getArea",
"computeAutoPlacement",
"placement",
"refRect",
"rects",
"sortedAreas",
"Object",
"keys",
"map",
"key",
"sort",
"a",
"b",
"area",
"filteredAreas",
"filter",
"computedPlacement",
"variation",
"split",
"getReferenceOffsets",
"state",
"commonOffsetParent",
"getOuterSizes",
"x",
"marginBottom",
"y",
"marginRight",
"getOppositePlacement",
"hash",
"replace",
"matched",
"getPopperOffsets",
"referenceOffsets",
"popperRect",
"popperOffsets",
"isHoriz",
"mainSide",
"secondarySide",
"measurement",
"secondaryMeasurement",
"find",
"arr",
"check",
"Array",
"prototype",
"findIndex",
"prop",
"value",
"cur",
"match",
"obj",
"runModifiers",
"modifiers",
"data",
"ends",
"modifiersToRun",
"undefined",
"slice",
"forEach",
"warn",
"enabled",
"update",
"isDestroyed",
"options",
"positionFixed",
"flip",
"originalPlacement",
"position",
"isCreated",
"onCreate",
"onUpdate",
"isModifierEnabled",
"modifierName",
"some",
"name",
"getSupportedPropertyName",
"prefixes",
"upperProp",
"charAt",
"toUpperCase",
"prefix",
"toCheck",
"style",
"destroy",
"removeAttribute",
"willChange",
"disableEventListeners",
"removeOnDestroy",
"removeChild",
"getWindow",
"attachToScrollParents",
"event",
"callback",
"scrollParents",
"isBody",
"target",
"addEventListener",
"passive",
"push",
"setupEventListeners",
"updateBound",
"scrollElement",
"eventsEnabled",
"enableEventListeners",
"scheduleUpdate",
"removeEventListeners",
"removeEventListener",
"isNumeric",
"n",
"isNaN",
"isFinite",
"setStyles",
"unit",
"setAttributes",
"attributes",
"setAttribute",
"applyStyle",
"instance",
"arrowElement",
"arrowStyles",
"applyStyleOnLoad",
"modifierOptions",
"getRoundedOffsets",
"shouldRound",
"round",
"floor",
"noRound",
"v",
"referenceWidth",
"popperWidth",
"isVertical",
"isVariation",
"sameWidthParity",
"bothOddWidth",
"horizontalToInteger",
"verticalToInteger",
"isFirefox",
"computeStyle",
"legacyGpuAccelerationOption",
"gpuAcceleration",
"offsetParentRect",
"devicePixelRatio",
"prefixedProperty",
"invertTop",
"invertLeft",
"arrow",
"isModifierRequired",
"requestingName",
"requestedName",
"requesting",
"isRequired",
"requested",
"querySelector",
"len",
"sideCapitalized",
"toLowerCase",
"altSide",
"opSide",
"arrowElementSize",
"center",
"popperMarginSide",
"popperBorderSide",
"sideValue",
"min",
"getOppositeVariation",
"validPlacements",
"placements",
"clockwise",
"counter",
"index",
"concat",
"reverse",
"BEHAVIORS",
"flipped",
"placementOpposite",
"flipOrder",
"behavior",
"FLIP",
"CLOCKWISE",
"COUNTERCLOCKWISE",
"step",
"refOffsets",
"overlapsRef",
"overflowsLeft",
"overflowsRight",
"overflowsTop",
"overflowsBottom",
"overflowsBoundaries",
"flippedVariationByRef",
"flipVariations",
"flippedVariationByContent",
"flipVariationsByContent",
"flippedVariation",
"keepTogether",
"toValue",
"str",
"size",
"parseOffset",
"basePlacement",
"useHeight",
"fragments",
"frag",
"trim",
"divider",
"search",
"splitRegex",
"ops",
"op",
"mergeWithPrevious",
"reduce",
"index2",
"preventOverflow",
"transformProp",
"popperStyles",
"transform",
"priority",
"escapeWithReference",
"shift",
"shiftvariation",
"shiftOffsets",
"hide",
"bound",
"inner",
"subtractLength",
"Popper",
"requestAnimationFrame",
"debounce",
"bind",
"Defaults",
"jquery",
"onLoad",
"Utils",
"global",
"PopperUtils"
],
mappings: "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"
}